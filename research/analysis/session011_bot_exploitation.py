#!/usr/bin/env python3
"""
Session 011 Part 3: Bot Exploitation Hypothesis Testing

Testing 5 Tier 1 Bot Hypotheses:
- H087: Round Size Bot Detection
- H088: Millisecond Burst Detection
- H090: Identical Consecutive Sizes
- H094: After-Hours Bot Dominance
- H097: Bot Disagreement Signal

Methodology:
1. Correct breakeven formula: breakeven = trade_price / 100
2. Price proxy check: improvement = signal_edge - baseline_edge (MUST be > 0)
3. Statistical significance: p < 0.01 (Bonferroni: 0.05 / 5 tests)
4. Validation: N >= 50 markets, concentration < 30%
"""

import pandas as pd
import numpy as np
from scipy import stats
from datetime import datetime
import json
import warnings
warnings.filterwarnings('ignore')

# Load data
print("Loading trade data...")
df = pd.read_csv('/Users/samuelclark/Desktop/kalshiflow/research/data/trades/enriched_trades_resolved_ALL.csv')
print(f"Loaded {len(df):,} trades")

# Convert timestamp to datetime
df['dt'] = pd.to_datetime(df['timestamp'], unit='ms')
df['hour_et'] = df['dt'].dt.tz_localize('UTC').dt.tz_convert('America/New_York').dt.hour

# Create result column
df['result_numeric'] = (df['market_result'] == 'yes').astype(int)

def calculate_strategy_edge(signal_trades, description=""):
    """
    Calculate edge for a set of trades using CORRECT methodology.

    Returns dict with:
    - markets: unique market count
    - win_rate: actual win rate
    - breakeven: required win rate
    - edge: win_rate - breakeven
    - profit: total profit
    - p_value: statistical significance
    - concentration: max single market contribution
    """
    if len(signal_trades) == 0:
        return None

    # Group by market - one bet per market
    market_agg = signal_trades.groupby('market_ticker').agg({
        'trade_price': 'mean',
        'market_result': 'first',  # All trades in same market have same result
        'actual_profit_dollars': 'sum',
        'count': 'sum'
    }).reset_index()

    n_markets = len(market_agg)
    if n_markets < 50:
        return {
            'status': 'INSUFFICIENT_MARKETS',
            'markets': n_markets,
            'description': description
        }

    # Calculate win rate (for the bet type implied by signal)
    # For YES bets: win when market_result == 'yes'
    # For NO bets: win when market_result == 'no'
    # We determine bet type from the signal definition

    # Default: calculate for NO bets (fade signal)
    market_agg['won'] = (market_agg['market_result'] == 'no').astype(int)
    win_rate = market_agg['won'].mean()

    # Breakeven for NO trades: avg NO price / 100
    avg_no_price = 100 - market_agg['trade_price'].mean()
    breakeven = avg_no_price / 100

    edge = (win_rate - breakeven) * 100

    # Total profit
    total_profit = market_agg['actual_profit_dollars'].sum()

    # Concentration
    market_profits = market_agg['actual_profit_dollars'].abs()
    if market_profits.sum() > 0:
        concentration = market_profits.max() / market_profits.sum()
    else:
        concentration = 0

    # Statistical significance
    # H0: win_rate = breakeven
    # Use one-sample proportion test
    n_wins = market_agg['won'].sum()
    binom_result = stats.binomtest(n_wins, n_markets, breakeven, alternative='greater')
    p_value = binom_result.pvalue

    return {
        'status': 'OK',
        'description': description,
        'markets': n_markets,
        'trades': len(signal_trades),
        'win_rate': win_rate,
        'breakeven': breakeven,
        'edge_pct': edge,
        'profit': total_profit,
        'concentration': concentration,
        'p_value': p_value,
        'avg_yes_price': market_agg['trade_price'].mean(),
        'avg_no_price': avg_no_price
    }


def calculate_baseline_edge(price_range, description=""):
    """
    Calculate baseline edge for trades at similar NO price range.
    This is the PRICE PROXY CHECK.
    """
    no_price_min, no_price_max = price_range
    baseline_trades = df[(df['no_price'] >= no_price_min) & (df['no_price'] <= no_price_max)]
    return calculate_strategy_edge(baseline_trades, description)


def price_proxy_check(signal_result, baseline_result):
    """
    Check if signal provides improvement over baseline.
    Returns the improvement (must be > 0 to pass).
    """
    if signal_result is None or baseline_result is None:
        return None
    if signal_result['status'] != 'OK' or baseline_result['status'] != 'OK':
        return None

    improvement = signal_result['edge_pct'] - baseline_result['edge_pct']
    return improvement


def validate_strategy(signal_trades, description):
    """
    Full validation of a strategy.
    Returns dict with validation results.
    """
    result = calculate_strategy_edge(signal_trades, description)

    if result is None or result['status'] != 'OK':
        return result

    # Get price-matched baseline
    avg_no_price = result['avg_no_price']
    price_range = (avg_no_price - 5, avg_no_price + 5)  # +/- 5c
    baseline = calculate_baseline_edge(price_range, f"Baseline NO at {avg_no_price:.0f}c")

    # Calculate improvement
    if baseline and baseline['status'] == 'OK':
        improvement = price_proxy_check(result, baseline)
        result['baseline_edge_pct'] = baseline['edge_pct']
        result['improvement_pct'] = improvement
        result['is_price_proxy'] = improvement <= 0 if improvement is not None else None
    else:
        result['baseline_edge_pct'] = None
        result['improvement_pct'] = None
        result['is_price_proxy'] = None

    # Validation criteria
    result['passes_markets'] = result['markets'] >= 50
    result['passes_concentration'] = result['concentration'] < 0.30
    result['passes_significance'] = result['p_value'] < 0.01  # Bonferroni: 0.05/5
    result['passes_proxy_check'] = not result['is_price_proxy'] if result['is_price_proxy'] is not None else False

    result['is_validated'] = all([
        result['passes_markets'],
        result['passes_concentration'],
        result['passes_significance'],
        result['passes_proxy_check']
    ])

    return result


print("\n" + "="*80)
print("TESTING BOT EXPLOITATION HYPOTHESES")
print("="*80)

results = {}

# ==============================================================================
# H087: Round Size Bot Detection
# ==============================================================================
print("\n" + "-"*40)
print("H087: Round Size Bot Detection")
print("-"*40)

# Define round sizes (bot-like)
ROUND_SIZES = [10, 25, 50, 100, 250, 500, 1000]

# Identify round-size trades
df['is_round_size'] = df['count'].isin(ROUND_SIZES)
round_size_trades = df[df['is_round_size']]
print(f"Round size trades: {len(round_size_trades):,} ({100*len(round_size_trades)/len(df):.1f}%)")

# Calculate consensus of round-size trades per market
round_consensus = round_size_trades.groupby('market_ticker').agg({
    'taker_side': lambda x: (x == 'yes').mean(),  # % YES trades
    'trade_price': 'mean',
    'market_result': 'first',
    'count': 'sum'
}).reset_index()
round_consensus.columns = ['market_ticker', 'yes_ratio', 'avg_price', 'market_result', 'total_count']

# Strategy: FADE when >60% round-size trades agree on YES
fade_threshold = 0.6
round_consensus['signal'] = round_consensus['yes_ratio'] > fade_threshold

# Get markets where signal triggered
signal_markets = round_consensus[round_consensus['signal']]['market_ticker'].tolist()
signal_trades = df[df['market_ticker'].isin(signal_markets)]

print(f"Markets with >60% round-size YES consensus: {len(signal_markets)}")

result_h087 = validate_strategy(signal_trades, "H087: Fade Round Size Bot Consensus (>60% YES)")
results['H087'] = result_h087

if result_h087 and result_h087['status'] == 'OK':
    print(f"Edge: {result_h087['edge_pct']:.1f}%")
    print(f"Markets: {result_h087['markets']}")
    print(f"P-value: {result_h087['p_value']:.4f}")
    print(f"Baseline edge: {result_h087.get('baseline_edge_pct', 'N/A')}")
    print(f"Improvement: {result_h087.get('improvement_pct', 'N/A')}")
    print(f"VALIDATED: {result_h087['is_validated']}")
else:
    print(f"Result: {result_h087}")

# Also test following round-size consensus
round_consensus['signal_follow'] = round_consensus['yes_ratio'] < (1 - fade_threshold)  # <40% YES = >60% NO
signal_markets_follow = round_consensus[round_consensus['signal_follow']]['market_ticker'].tolist()
signal_trades_follow = df[df['market_ticker'].isin(signal_markets_follow)]

print(f"\nMarkets with >60% round-size NO consensus: {len(signal_markets_follow)}")
result_h087_follow = validate_strategy(signal_trades_follow, "H087b: Follow Round Size Bot NO Consensus (>60% NO)")
results['H087_follow'] = result_h087_follow

if result_h087_follow and result_h087_follow['status'] == 'OK':
    print(f"Edge: {result_h087_follow['edge_pct']:.1f}%")
    print(f"Markets: {result_h087_follow['markets']}")
    print(f"Improvement: {result_h087_follow.get('improvement_pct', 'N/A')}")

# ==============================================================================
# H088: Millisecond Burst Detection
# ==============================================================================
print("\n" + "-"*40)
print("H088: Millisecond Burst Detection")
print("-"*40)

# Group trades by market and second (timestamp // 1000)
df['timestamp_sec'] = df['timestamp'] // 1000
burst_counts = df.groupby(['market_ticker', 'timestamp_sec']).size().reset_index(name='trades_in_second')

# Find bursts (3+ trades in same second)
bursts = burst_counts[burst_counts['trades_in_second'] >= 3]
print(f"Burst events (3+ trades/sec): {len(bursts):,}")

# Get markets with bursts
burst_markets = bursts['market_ticker'].unique()
print(f"Markets with bursts: {len(burst_markets)}")

# Calculate burst direction consensus
burst_trades = df.merge(bursts[['market_ticker', 'timestamp_sec']], on=['market_ticker', 'timestamp_sec'])
print(f"Trades in bursts: {len(burst_trades):,}")

# Consensus per burst
burst_consensus = burst_trades.groupby(['market_ticker', 'timestamp_sec']).agg({
    'taker_side': lambda x: (x == 'yes').mean()
}).reset_index()
burst_consensus.columns = ['market_ticker', 'timestamp_sec', 'yes_ratio']

# Find markets where burst consensus >80% YES
high_consensus_bursts = burst_consensus[burst_consensus['yes_ratio'] > 0.8]
signal_markets_h088 = high_consensus_bursts['market_ticker'].unique()
signal_trades_h088 = df[df['market_ticker'].isin(signal_markets_h088)]

print(f"Markets with >80% YES burst consensus: {len(signal_markets_h088)}")

result_h088 = validate_strategy(signal_trades_h088, "H088: Follow Burst Consensus (>80% YES in same second)")
results['H088'] = result_h088

if result_h088 and result_h088['status'] == 'OK':
    print(f"Edge: {result_h088['edge_pct']:.1f}%")
    print(f"Markets: {result_h088['markets']}")
    print(f"P-value: {result_h088['p_value']:.4f}")
    print(f"Improvement: {result_h088.get('improvement_pct', 'N/A')}")
    print(f"VALIDATED: {result_h088['is_validated']}")
else:
    print(f"Result: {result_h088}")

# Also test FADING burst consensus
fade_burst_markets = burst_consensus[burst_consensus['yes_ratio'] > 0.8]['market_ticker'].unique()
# For fading, we calculate edge differently - we're betting NO
signal_trades_h088_fade = df[df['market_ticker'].isin(fade_burst_markets)]

result_h088_fade = validate_strategy(signal_trades_h088_fade, "H088b: FADE Burst Consensus (Fade >80% YES bursts)")
results['H088_fade'] = result_h088_fade

if result_h088_fade and result_h088_fade['status'] == 'OK':
    print(f"\nFADE Burst Edge: {result_h088_fade['edge_pct']:.1f}%")
    print(f"Improvement: {result_h088_fade.get('improvement_pct', 'N/A')}")

# ==============================================================================
# H090: Identical Consecutive Sizes
# ==============================================================================
print("\n" + "-"*40)
print("H090: Identical Consecutive Sizes")
print("-"*40)

# Sort by market and timestamp
df_sorted = df.sort_values(['market_ticker', 'timestamp'])

# Find sequences of 3+ identical sizes in same direction
df_sorted['prev_count'] = df_sorted.groupby('market_ticker')['count'].shift(1)
df_sorted['prev_prev_count'] = df_sorted.groupby('market_ticker')['count'].shift(2)
df_sorted['prev_side'] = df_sorted.groupby('market_ticker')['taker_side'].shift(1)
df_sorted['prev_prev_side'] = df_sorted.groupby('market_ticker')['taker_side'].shift(2)

# Identify sequences: same count, same direction for 3 consecutive trades
df_sorted['is_sequence'] = (
    (df_sorted['count'] == df_sorted['prev_count']) &
    (df_sorted['count'] == df_sorted['prev_prev_count']) &
    (df_sorted['taker_side'] == df_sorted['prev_side']) &
    (df_sorted['taker_side'] == df_sorted['prev_prev_side'])
)

sequence_trades = df_sorted[df_sorted['is_sequence']]
print(f"Sequence trades (3+ identical size+direction): {len(sequence_trades):,}")

# Get markets with sequences
sequence_markets = sequence_trades['market_ticker'].unique()
print(f"Markets with sequences: {len(sequence_markets)}")

# Calculate sequence direction consensus
sequence_consensus = sequence_trades.groupby('market_ticker').agg({
    'taker_side': lambda x: (x == 'yes').mean(),
    'market_result': 'first'
}).reset_index()

# Follow accumulation: bet same direction as sequence
# Get markets where sequences are mostly YES
signal_markets_h090 = sequence_consensus[sequence_consensus['taker_side'] > 0.5]['market_ticker'].tolist()
signal_trades_h090 = df[df['market_ticker'].isin(signal_markets_h090)]

print(f"Markets with YES accumulation sequences: {len(signal_markets_h090)}")

result_h090 = validate_strategy(signal_trades_h090, "H090: Follow Bot Accumulation (3+ identical YES trades)")
results['H090'] = result_h090

if result_h090 and result_h090['status'] == 'OK':
    print(f"Edge: {result_h090['edge_pct']:.1f}%")
    print(f"Markets: {result_h090['markets']}")
    print(f"P-value: {result_h090['p_value']:.4f}")
    print(f"Improvement: {result_h090.get('improvement_pct', 'N/A')}")
    print(f"VALIDATED: {result_h090['is_validated']}")
else:
    print(f"Result: {result_h090}")

# Also test fading accumulation
signal_markets_h090_fade = sequence_consensus[sequence_consensus['taker_side'] > 0.5]['market_ticker'].tolist()
signal_trades_h090_fade = df[df['market_ticker'].isin(signal_markets_h090_fade)]
# Fade = bet NO when they're accumulating YES

result_h090_fade = validate_strategy(signal_trades_h090_fade, "H090b: FADE Bot Accumulation")
results['H090_fade'] = result_h090_fade

if result_h090_fade and result_h090_fade['status'] == 'OK':
    print(f"\nFADE Accumulation Edge: {result_h090_fade['edge_pct']:.1f}%")

# ==============================================================================
# H094: After-Hours Bot Dominance
# ==============================================================================
print("\n" + "-"*40)
print("H094: After-Hours Bot Dominance (2AM-6AM ET)")
print("-"*40)

# Filter for 2AM-6AM ET trades
after_hours_trades = df[(df['hour_et'] >= 2) & (df['hour_et'] < 6)]
print(f"After-hours trades (2-6AM ET): {len(after_hours_trades):,} ({100*len(after_hours_trades)/len(df):.1f}%)")

# Get markets with after-hours activity
after_hours_markets = after_hours_trades['market_ticker'].unique()
print(f"Markets with after-hours activity: {len(after_hours_markets)}")

# Calculate consensus in after-hours
ah_consensus = after_hours_trades.groupby('market_ticker').agg({
    'taker_side': lambda x: (x == 'yes').mean(),
    'market_result': 'first'
}).reset_index()
ah_consensus.columns = ['market_ticker', 'yes_ratio', 'market_result']

# FADE after-hours direction
# If after-hours is mostly YES (>60%), bet NO
signal_markets_h094 = ah_consensus[ah_consensus['yes_ratio'] > 0.6]['market_ticker'].tolist()
signal_trades_h094 = df[df['market_ticker'].isin(signal_markets_h094)]

print(f"Markets with >60% YES in after-hours: {len(signal_markets_h094)}")

result_h094 = validate_strategy(signal_trades_h094, "H094: FADE After-Hours YES Consensus")
results['H094'] = result_h094

if result_h094 and result_h094['status'] == 'OK':
    print(f"Edge: {result_h094['edge_pct']:.1f}%")
    print(f"Markets: {result_h094['markets']}")
    print(f"P-value: {result_h094['p_value']:.4f}")
    print(f"Improvement: {result_h094.get('improvement_pct', 'N/A')}")
    print(f"VALIDATED: {result_h094['is_validated']}")
else:
    print(f"Result: {result_h094}")

# Also test FOLLOWING after-hours
signal_markets_h094_follow = ah_consensus[ah_consensus['yes_ratio'] < 0.4]['market_ticker'].tolist()
signal_trades_h094_follow = df[df['market_ticker'].isin(signal_markets_h094_follow)]

print(f"\nMarkets with >60% NO in after-hours: {len(signal_markets_h094_follow)}")
result_h094_follow = validate_strategy(signal_trades_h094_follow, "H094b: Follow After-Hours NO Consensus")
results['H094_follow'] = result_h094_follow

if result_h094_follow and result_h094_follow['status'] == 'OK':
    print(f"Edge: {result_h094_follow['edge_pct']:.1f}%")
    print(f"Improvement: {result_h094_follow.get('improvement_pct', 'N/A')}")

# ==============================================================================
# H097: Bot Disagreement Signal
# ==============================================================================
print("\n" + "-"*40)
print("H097: Bot Disagreement/Agreement Signal")
print("-"*40)

# Composite bot score: combine multiple bot indicators
# 1. Round size
# 2. Part of burst
# 3. Part of sequence

# Already have is_round_size
# Add burst indicator
df['is_burst'] = df.groupby(['market_ticker', 'timestamp_sec'])['timestamp_sec'].transform('count') >= 3

# Add sequence indicator (simplified)
df['is_bot_like'] = df['is_round_size'] | df['is_burst']

bot_trades = df[df['is_bot_like']]
print(f"Bot-like trades: {len(bot_trades):,} ({100*len(bot_trades)/len(df):.1f}%)")

# Calculate bot consensus per market
bot_consensus = bot_trades.groupby('market_ticker').agg({
    'taker_side': lambda x: (x == 'yes').mean(),
    'market_result': 'first',
    'count': 'sum'
}).reset_index()
bot_consensus.columns = ['market_ticker', 'yes_ratio', 'market_result', 'total_count']

# Follow when >80% of bots agree
high_consensus = bot_consensus[bot_consensus['yes_ratio'] > 0.8]
signal_markets_h097 = high_consensus['market_ticker'].tolist()
signal_trades_h097 = df[df['market_ticker'].isin(signal_markets_h097)]

print(f"Markets with >80% bot YES consensus: {len(signal_markets_h097)}")

result_h097 = validate_strategy(signal_trades_h097, "H097: Follow Bot Consensus (>80% YES)")
results['H097'] = result_h097

if result_h097 and result_h097['status'] == 'OK':
    print(f"Edge: {result_h097['edge_pct']:.1f}%")
    print(f"Markets: {result_h097['markets']}")
    print(f"P-value: {result_h097['p_value']:.4f}")
    print(f"Improvement: {result_h097.get('improvement_pct', 'N/A')}")
    print(f"VALIDATED: {result_h097['is_validated']}")
else:
    print(f"Result: {result_h097}")

# Also test FADING bot consensus
result_h097_fade = validate_strategy(signal_trades_h097, "H097b: FADE Bot Consensus (Fade >80% YES)")
results['H097_fade'] = result_h097_fade

if result_h097_fade and result_h097_fade['status'] == 'OK':
    print(f"\nFADE Bot Consensus Edge: {result_h097_fade['edge_pct']:.1f}%")
    print(f"Improvement: {result_h097_fade.get('improvement_pct', 'N/A')}")

# ==============================================================================
# SUMMARY
# ==============================================================================
print("\n" + "="*80)
print("TIER 1 BOT HYPOTHESES SUMMARY")
print("="*80)

summary_table = []
for h_id, result in results.items():
    if result and result['status'] == 'OK':
        summary_table.append({
            'Hypothesis': h_id,
            'Description': result['description'][:40] + '...' if len(result['description']) > 40 else result['description'],
            'Markets': result['markets'],
            'Edge': f"{result['edge_pct']:.1f}%",
            'P-value': f"{result['p_value']:.4f}",
            'Improvement': f"{result.get('improvement_pct', 'N/A'):.1f}%" if result.get('improvement_pct') is not None else 'N/A',
            'Validated': 'YES' if result['is_validated'] else 'NO'
        })
    else:
        summary_table.append({
            'Hypothesis': h_id,
            'Description': result.get('description', 'N/A') if result else 'N/A',
            'Markets': result.get('markets', 0) if result else 0,
            'Edge': 'N/A',
            'P-value': 'N/A',
            'Improvement': 'N/A',
            'Validated': 'INSUFFICIENT'
        })

summary_df = pd.DataFrame(summary_table)
print(summary_df.to_string(index=False))

# Save results
output_path = '/Users/samuelclark/Desktop/kalshiflow/research/reports/session011_bot_results.json'
with open(output_path, 'w') as f:
    # Convert numpy types to native Python types
    def convert_types(obj):
        if isinstance(obj, (np.int64, np.int32)):
            return int(obj)
        elif isinstance(obj, (np.float64, np.float32)):
            return float(obj)
        elif isinstance(obj, np.bool_):
            return bool(obj)
        elif isinstance(obj, dict):
            return {k: convert_types(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [convert_types(i) for i in obj]
        return obj

    json.dump(convert_types(results), f, indent=2)
print(f"\nResults saved to: {output_path}")

# ==============================================================================
# CHECK FOR ANY VALIDATED STRATEGIES
# ==============================================================================
print("\n" + "="*80)
print("VALIDATED STRATEGIES CHECK")
print("="*80)

validated = [h_id for h_id, r in results.items() if r and r.get('is_validated')]
if validated:
    print(f"VALIDATED: {validated}")
    for h_id in validated:
        print(f"\n{h_id}:")
        print(json.dumps(convert_types(results[h_id]), indent=2))
else:
    print("NO TIER 1 HYPOTHESES VALIDATED")
    print("\nMoving to Tier 2 hypotheses...")
